{"meta":{"title":"和光同其尘个人博客 - 一个爱分享Java技术的个人博客网站","subtitle":"一个爱分享Java技术的个人博客网站","description":"和光同其尘的个人博客,分享java生态、spring生态、微服务相关技术知识!","author":"和光同其尘","url":"https://zhanyu1.github.io"},"pages":[{"title":"关于我","date":"2019-06-15T13:26:13.000Z","updated":"2019-06-23T09:18:54.403Z","comments":false,"path":"about/index.html","permalink":"https://zhanyu1.github.io/about/index.html","excerpt":"","text":"和光同其尘通信工程小硕一枚，目前在深圳，就职于某金融科技公司，专注于微服务公共组件的研究与落地。 联系方式 Email：2515936342@qq.com 微信：zhanyu_10（添加好友请注明：姓名+来意） 我的站点 CSDN：https://blog.csdn.net/zhanyu1"},{"title":"categories","date":"2019-06-15T11:07:47.000Z","updated":"2019-06-16T03:08:48.369Z","comments":false,"path":"categories/index.html","permalink":"https://zhanyu1.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-06-15T12:23:28.000Z","updated":"2019-06-15T12:24:02.763Z","comments":true,"path":"archives/index.html","permalink":"https://zhanyu1.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-15T11:00:59.000Z","updated":"2019-06-16T03:09:07.930Z","comments":false,"path":"tags/index.html","permalink":"https://zhanyu1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring的BeanFactoryPostProcessor和BeanPostProcessor区别","slug":"Spring的BeanFactoryPostProcessor和BeanPostProcessor区别","date":"2019-06-17T09:10:28.000Z","updated":"2019-06-23T09:14:49.282Z","comments":true,"path":"2019/06/17/Spring的BeanFactoryPostProcessor和BeanPostProcessor区别/","link":"","permalink":"https://zhanyu1.github.io/2019/06/17/Spring的BeanFactoryPostProcessor和BeanPostProcessor区别/","excerpt":"","text":"BeanFactoryPostProcessor：BeanFactory后置处理器，是对BeanDefinition对象进行修改。（BeanDefinition：存储bean标签的信息，用来生成bean实例）BeanPostProcessor：Bean后置处理器，是对生成的Bean对象进行修改。 一、BeanFactoryPostProcessor该接口源码如下： public interface BeanFactoryPostProcessor { //可以通过beanFactory获取bean定义信息 void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } BeanFactoryPostProcessor接口是针对bean容器的，它的实现类可以在当前BeanFactory初始化（spring容器加载bean定义文件）后，bean实例化之前修改bean的定义属性，达到影响之后实例化bean的效果。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置’order’属性来控制各个BeanFactoryPostProcessor的执行次序。spring中内置了一些BeanFactoryPostProcessor接口实现类，如下所示： 二、BeanPostProcessor该方法的源码如下： public interface BeanPostProcessor { //bean初始化之前调用 @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } //bean初始化之后调用 @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; } } BeanPostProcessor能在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。初始化方法包括以下两种： 1、实现InitializingBean接口的bean，对应方法为afterPropertiesSet2、xml定义中，通过init-method设置的方法 BeanPostProcessor是BeanFactoryPostProcessor之后执行的。spring中内置了一些BeanPostProcessor接口实现类，如下所示：如果自定义了多个的BeanPostProcessor的实现类，通过实现Ordered接口，设置order属性，可以按照顺序执行实现类的方法。 三、例子（链接：https://blog.csdn.net/caihaijiang/article/details/35552859）1、bean的定义 public class CustomBean implements InitializingBean { private String desc; private String remark; public CustomBean() { System.out.println(\"第二步：执行CustomBean类的无参构造函数\"); } public String getDesc() { return desc; } public void setDesc(String desc) { System.out.println(\"第三步：调用setDesc方法\"); this.desc = desc; } public String getRemark() { return remark; } public void setRemark(String remark) { System.out.println(\"第四步：调用setRemark方法\"); this.remark = remark; } public void afterPropertiesSet() throws Exception { System.out.println(\"第六步：调用afterPropertiesSet方法\"); this.desc = \"在初始化方法中修改之后的描述信息\"; } public void initMethod() { System.out.println(\"第七步：调用initMethod方法\"); } public String toString() { StringBuilder builder = new StringBuilder(); builder.append(\"[描述：\").append(desc); builder.append(\"， 备注：\").append(remark).append(\"]\"); return builder.toString(); } } 2、定义BeanFactoryPostProcessor public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println(\"第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory\"); BeanDefinition bd = beanFactory.getBeanDefinition(\"customBean\"); MutablePropertyValues pv = bd.getPropertyValues(); if (pv.contains(\"remark\")) { pv.addPropertyValue(\"remark\", \"在BeanFactoryPostProcessor中修改之后的备忘信息\"); } } } 3、定义BeanPostProcessor public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"第五步：BeanPostProcessor，对象\" + beanName + \"调用初始化方法之前的数据： \" + bean.toString()); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"第八步：BeanPostProcessor，对象\" + beanName + \"调用初始化方法之后的数据：\" + bean.toString()); return bean; } } 4、定义测试类 public class PostProcessorTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"spring/postprocessor.xml\"); CustomBean bean = (CustomBean) context.getBean(\"customBean\"); System.out.println(\"################ 实例化、初始化bean完成\"); System.out.println(\"****************下面输出结果\"); System.out.println(\"描述：\" + bean.getDesc()); System.out.println(\"备注：\" + bean.getRemark()); } } 运行结果如下： 第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory 第二步：执行CustomBean类的无参构造函数 第三步：调用setDesc方法 第四步：调用setRemark方法 第五步：BeanPostProcessor，对象customBean调用初始化方法之前的数据： [描述：原始的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息] 第六步：调用afterPropertiesSet方法 第七步：调用initMethod方法 第八步：BeanPostProcessor，对象customBean调用初始化方法之后的数据：[描述：在初始化方法中修改之后的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息] ################ 实例化、初始化bean完成 ****************下面输出结果 描述：在初始化方法中修改之后的描述信息 备注：在BeanFactoryPostProcessor中修改之后的备忘信息 ************************************************************************* 分析以上结果：在bean实例化之前，首先执行BeanFactoryPostProcessor实现类的方法，然后通过调用bean的无参构造函数实例化bean，并调用set方法注入属性值。bean实例化后，执行初始化操作，调用两个初始化方法（两个初始化方法的顺序：先执行afterPropertiesSet，再执行init-method）前后，执行了BeanPostProcessor实现类的两个方法。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://zhanyu1.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhanyu1.github.io/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"https://zhanyu1.github.io/categories/Spring/"}]},{"title":"UML类图详解","slug":"UML类图详解","date":"2019-06-15T12:23:28.000Z","updated":"2019-06-22T11:58:02.917Z","comments":true,"path":"2019/06/15/UML类图详解/","link":"","permalink":"https://zhanyu1.github.io/2019/06/15/UML类图详解/","excerpt":"","text":"注明：本文画图工具为StarUML 一、概述1.1、类图介绍首先介绍下类图，定义一个Person类，如下： 123456789101112131415161718public class Person &#123; private String name; private int age =1; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name=name; &#125; public void setAge(int age) &#123; this.age=age; &#125;&#125; 定义了两个字段name和age，其中age有一个初始化值1，另外定义name和age的set、get方法。然后我们来看下这个类在UML类图中是如何表示的：可以看到我们画了一个矩形，然后从上到下分割成三格，第一格为类名，第二格为类中字段属性，这里属性的表达也是有一定格式的，如下： 权限 属性名：类型 [ = 默认值 ] 由于这里我们的name和age都是私有的，所以在前面加一个-，另外还有其他几种权限：public 、protected、default，它们分别对应+、#、~。由于我们这里的age有一个默认值1，所以在类型后面再加上‘=1’来表示。接下来来看下第三格，第三格为类的方法，其格式如下： 权限 方法名称(参数列表) [ : 返回类型] 中括号代表可选项。 1.2、类与类之间的关系在画类图时，首先要清晰类和类之间的关系。类与类的关系总共有以下几种：泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）。 这6种关系的强弱顺序为：泛化=实现&gt;组合&gt;聚合&gt;关联&gt;依赖； 二、类关系详解 2.1、泛化泛化表示is-a的关系，在Java中也叫作继承关系，在UML中用带空心三角形的直线来表示，箭头从子类指向父类，是对象之间耦合度最大的一种关系。增加两个类，一个Studen类，一个警察Policemen类，两个类均继承自Person类，那么他们的类关系图表示如下： 2.2、实现这里的实现关系就是Java中类与接口的实现关系，在UML中用带空心三角形的虚线表示。由于Student和Policeman都职业，学生的职业就是学习，而警察的职业为保护人民。所有这里我们定义一个接口，里面有一个职业的方法： public interface ICareer{ void career();} 这个接口用UML类图表示如下：可以看到在接口名字上多了一个&lt;&gt;字符来表示这个为接口。接下来我们让Student和Policeman都实现这个接口，UML类图如下： 2.3、依赖依赖是对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。这里学生捡到钱交给警察叔叔，学生和警察叔叔就是一种依赖关系。因为学生捡到钱给警察是一种偶然的事情，交给警察后他们之间就没有关系了。我们在学生类中加入一个交钱的方法，在警察类中加入一个收钱的方法，当调用学生的交钱方法时，就调用警察的收钱方法。Student的代码如下： 12345678public class Student&#123;public Policemen policemen;public void sendCoin()&#123; policemen.receiveCoin();&#125;&#125; 可以看到Student类中引用了Policemen类，也就是说Student依赖了Policemen，这种依赖关系我们用带箭头的虚线表示，箭头指向被依赖对象，这里也就是Policemen，UML类图表示如下： 2.4、关联关联是一种比较强的关系，他们的关系是比较持久的，稳定的。比如学生从家里出来，学生和家就是一种关联关系。这种关系是比较稳定的。关联分单向关联和双向关联，如果一个类知道或者引用了另一个类，而另一个类不知道或者没有引用这个类，则这两个类是单向关联的。比如这里学生与家的关系就是单向关联的，因为每个学生都是有个家的（不考虑孤儿），但不能说每个家里都有学生。 单向关联我们用带箭头的实线表示，箭头指向被引用或者被包含的类，这里也就是家这个类。示例如下：双向关联是两个类彼此都知道对方的存在，比如老师与学生的关系就是双向的。小明的语文老师是张老师，张老师的学生有小明。双向关联用不带箭头的实线来连接两个类。示例如下： 2.5、聚合聚合关系表示has-a的关系，是一种不稳定的包含关系。强调的是整体和部分的关系，其中部分可以脱离整体而存在。比如雁群和一只大雁的关系，就是聚合关系，大雁离开雁群还是可以独立存在的。再比如警察与制服的关系，制服也是警察的一部分，制服可以脱离警察而存在。在UML类图中聚合用带空心菱形的直线表示，其中菱形从局部指向整体。 2.6、组合组合表示contains-a的关系，是一种强烈的包含关系。它与聚合关系很像，也是强调整体与部分的关系，不同的是部分无法脱离整体存在。比如学生用手捡钱，其中手就是学生的一部分，但是手不能脱离学生而单独存在。这里称学生与手为组合关系，用带实心的菱形直线表示，其中菱形指向整体：","categories":[{"name":"UML","slug":"UML","permalink":"https://zhanyu1.github.io/categories/UML/"}],"tags":[{"name":"UML","slug":"UML","permalink":"https://zhanyu1.github.io/tags/UML/"}],"keywords":[{"name":"UML","slug":"UML","permalink":"https://zhanyu1.github.io/categories/UML/"}]}]}